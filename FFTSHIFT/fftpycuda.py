# -*- coding: utf-8 -*-
"""FFTPyCUDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p3_g05HHZNfUEAAwIkkv9PT8wZMEFnhb
"""

pip install pycuda

"""Install the scikit-cuda package containing the FFT facilities."""

pip install scikit-cuda

import numpy as np

import pycuda.autoinit
import pycuda.gpuarray as gpuarray
import pycuda.cumath
from pycuda.compiler import SourceModule

from skcuda import fft

import matplotlib.pyplot as plt

###################
# iDivUp FUNCTION #
###################
def iDivUp(a, b):
    # Round a / b to nearest higher integer value
    a = np.int32(a)
    b = np.int32(b)
    return (a / b + 1) if (a % b != 0) else (a / b)

"""Without fftshift."""

M = 25

h_x = np.ones((M, 1), dtype = np.complex64)
d_x = gpuarray.to_gpu(h_x)

d_y = gpuarray.empty_like(d_x, dtype = np.complex64)

plan = fft.Plan(d_x.shape, np.complex64, np.complex64)
fft.fft(d_x, d_y, plan)
  
h_y = d_y.get()

plt.plot(np.abs(h_y))
plt.ylabel('FFT')
plt.show()

"""With fftshift."""

mod = SourceModule("""

#define PI_f      3.1415927410125732421875

/***************/
/* FFTSHIFT 1D */
/***************/
__global__ void ffthisft_1d_complex64_even(float2 *u_d, int N)
{
  int i = blockDim.x * blockIdx.x + threadIdx.x;
  if(i < N)
  {
    //float a = pow(-1.0f, i&1);
    float a = (float)(1-2*((int)i%2));
    u_d[i].x *= a;
    u_d[i].y *= a;
  }
}


__global__ void ffthisft_1d_complex64_odd(float2 *u_d, int N)
{
  int i = blockDim.x * blockIdx.x + threadIdx.x;
  if(i < N)
  {
    float2 a, out;
    a.x           = cosf(PI_f * (N - 1) * i / N);
    a.y           = sinf(PI_f * (N - 1) * i / N);
    out.x         = u_d[i].x * a.x - u_d[i].y * a.y;
    out.y         = u_d[i].y * a.x + u_d[i].x * a.y;
    u_d[i]        = out;
  }
}

""")

ffthisft_1d_complex64_even 		= mod.get_function("ffthisft_1d_complex64_even")
ffthisft_1d_complex64_odd 		= mod.get_function("ffthisft_1d_complex64_odd")

def fftshift_1d_complex64(d_x, M, blockDim, gridDim):
  if (M % 2) == 0:
    ffthisft_1d_complex64_even(d_x, np.int32(M), block = blockDim, grid = gridDim)
  else:
    ffthisft_1d_complex64_odd(d_x, np.int32(M), block = blockDim, grid = gridDim)

  return d_x

BLOCKSIZE = 256

blockDim  = (BLOCKSIZE, 1, 1)
gridDim   = (int(iDivUp(M, BLOCKSIZE)), 1, 1)

fftshift_1d_complex64(d_x, M, blockDim, gridDim)
fft.fft(d_x, d_y, plan)
  
h_y = d_y.get()

plt.plot(np.abs(h_y))
plt.ylabel('FFT')
plt.show()

print(h_y)